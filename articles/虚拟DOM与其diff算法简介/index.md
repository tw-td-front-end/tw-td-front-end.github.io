> 原文摘自 https://github.com/something-want-to-say/puzzle/issues/11

在这个病毒环绕的时间段里，通过几天的文章阅读，有解决了自己的一个~遗留依旧的~问题。今天则是要说一下这个虚拟DOM的事情。在_文章的最后，我会将参考的文章列出。_
还是作为一个前端开发人员，那么就在来了解一下虚拟DOM（Virtual DOM），其实这东西也在15年的时候就已经有一篇文章说明了，当时还是因为react兴起后，为了解释这个虚拟DOM的好处来说明的。在这里还是简单的说明一下。
在这个主流使用前端框架的时代，react， vue，angular_（特别指明是Angular，而非AngularJS）_，它们~一个个都~使用了虚拟DOM这个里面，进行实现页面渲染。
说了那么多没用过的废话，先介绍虚拟DOM。

### 虚拟DOM（Virtual DOM）

虚拟DOM就是对真是DOM的一个抽象，并且用Javascript的对象作为基础的树。换句话说就是，我们就是把真是DOM通过渲染函数（h函数）转义后得到的一个树形结构的对象集。用代码展示则为：

``` html
这是真是DOM
<div class=“div-class”>
	<span>test</span>
</div>
```
转义后（h函数）

``` javascript
这是虚拟DOM
{
	tag: div,
	attrs: {
		className: ‘div-class’
	},
	children: [
		{
			tag: span,
			attrs: {},
			children: [
				‘test’
			]
		}
	]
}
```
以上就是虚拟DOM，是不是瞬间就理解了，每一个子对象，至少包含以下三种属性：tag，attrs，children。不同框架编译后对其命名也不同，不在这里详细说了。接下来最想分享的东西，虚拟DOM diff算法。为什么我们会觉得虚拟DOM的性能会比直接操作DOM好，一点是因为直接操作了的虚DOM（即js代码），通过对新旧虚拟DOM的比较从而快速找到对应改变的节点，进行跟新。二是因为虚拟DOM就像在JS与DOM之间做了一个缓存。
>[CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）](https://www.zhihu.com/question/29504639)

说了那么多，就有人问，如果我直接在代码中改了一个元素的位置或者属性，会怎么样，和我们虚拟DOM有什么关系，这个时候就真的派上了虚拟DOM了，如果只是第一次渲染，那么虚拟DOM就没有什么用了，它的最大用处就在于进行新树与老树的对比，接下来我们来说明一下虚拟DOM的diff算法。

----

### 虚拟DOM diff算法

直接进入主题，整个diff算法，分别进行以下三个步骤：
1. 构建虚拟DOM树
2. 比较两个虚拟DOM树的差异
3. 将差异应用到真实的DOM树上

#### 1. 构建虚拟DOM树

 这个步骤比较简单，就是转成JS的对象结构，其中包含tag，attrs，children。~这个前面也说了~当虚拟DOM树构建好之后，就进入下一步，比较差异。

#### 2. 比较两个虚拟DOM树的差异

他们的比较只是相同层级之前的比较。_但是为什么，我也是没有找到相关资料进行说明。_搜索全网之后，得到的信息是：

>”但是在前端中，你会很少跨层地移动DOM元素，所以真实的DOM算法会对同一个层级的元素进行对比。”

_其实这个并没有说服力，等我之后研究了vue 3.0的diff算法优化后，再进行说明吧。_
盗图说明：这就是同级比较

![image](https://user-images.githubusercontent.com/9898513/75605134-04bd9780-5b1b-11ea-9e07-348c9edc53da.png)

接下来会进行：

**深度优先遍历**，在遍历时，需要为每个节点设置一个key值，这就是我们在实现中为什么会说，不要用index作为key的原因，如果同层级中的key是index，在进行比较时，会认为只是元素内容变动，而元素没有变动，~俗称诡异现象。给个文章看看~[react反模式——将数组的index作为key](https://www.jianshu.com/p/c74624223986)。

在遍历期间，还需做一件事件为：**记录差异**，在比较时，需分别进行归类：

1. 替换掉原来的节点
2. 移动、删除、新增子节点
3. 修改了节点的属性
4. 文本节点内容比较

首先上面的分类中，1，3，4都是比较简单，没有特别的算法进行比较：

>>**1** 为判断节点tag是否相同，如果不同，直接调换掉。
**3** 为判断attrs是否变动，如有变动，直接更改为新的则好。
**4** 为判断文本节点内容是否有更改，如更改，替换。

其次为**2**这个操作。前面我说了，在比较时，我们只进行同层的比较。因此，到这个操作的时，会出现以下情况：

* a. 不同tag的移动、删除或新增。
* b. 相同tag的移动、删除或新增。

这时我们进行的的是`列表对比`_具体可以参考[Vue列表渲染性能优化原理](https://github.com/banama/aboutVue/blob/master/diff.md)_，在比较时，使用key进行比较，这就是我们前面说的那个问题，`将数组的index作为key`是错误的做法。

当比较完后，最后这是将差异应用到真实的DOM中。然后大功告成，新的就渲染上次了。

----


+ ****列表对比****

通过了解，在这里简要说明，没有高深的专业术语，直接举例子说明：

旧的树（old）：a, b, c
新的树（new）：a, c, d, b

>> 第一步：比较第一个元素a，发现位置old与new位置不变，则不动，dom树为：a, b, c
第二步：比较完第一个元素后，直接比较第二个元素b，发现b移动到最后，此时dom树为：a, c, b
第三步：比较发现c的位置为上次移动位置的第二个，则保持不动，此时dom树为：a, c, b
第四步：发现old已经遍历完，new还有一个元素没有遍历，则认为没有比那里的元素为新增元素，根据inde，直接插入到对应的dom上，此时为：a, c, d, b

以上为比较算法简单介绍，如果old晚于new遍历完，则认为删除了元素，则直接从dom中，更加index直接删除则可。

以上全部为虚拟DOM的介绍与虚拟DOM diff算法简介，期待下一次的相遇，最近vue 3.0已经退出，需要看看到底有什么更新。
